<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Colour Splash: Analog Edition</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: white; touch-action: none; user-select: none; }
        
        /* --- HOST UI --- */
        #host-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; }
        
        #qr-panel { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(255,255,255,0.95); color: #333; padding: 30px; border-radius: 15px; 
            text-align: center; border: 4px solid #333; box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 100;
        }
        
        #qrcode { background: white; padding: 10px; margin: 15px auto; width: fit-content; border: 1px solid #ccc; }
        #host-id-display { font-size: 24px; font-weight: bold; border: 2px dashed #999; padding: 5px; margin: 10px 0; background: #eee; }

        /* HUD */
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box;}
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; }
        .score-box { background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 10px; font-weight: bold; font-size: 24px; text-align: center; min-width: 100px; color: white; }
        .score-p1 { border-bottom: 5px solid #ff4444; }
        .score-p2 { border-bottom: 5px solid #4488ff; }
        #timer-box { font-size: 40px; font-weight: 900; background: #333; padding: 5px 30px; border-radius: 20px; border: 2px solid white; }

        #game-over { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; color: black; padding: 40px; border-radius: 20px; text-align: center; z-index: 200; box-shadow: 0 0 100px black; }

        /* --- CLIENT UI --- */
        #client-ui { display: none; width: 100%; height: 100vh; background: #222; overflow: hidden; }
        
        #manual-login {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #eee; color: #333; z-index: 50;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        input { padding: 15px; font-size: 18px; text-align: center; width: 70%; margin-bottom: 20px; border-radius: 8px; border: 1px solid #ccc; }
        button.join-btn { padding: 15px 40px; font-size: 18px; background: #333; color: white; border: none; border-radius: 8px; font-weight: bold; }
        
        /* JOYSTICK AREA */
        #zone_joystick {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #333 1%, #111 100%);
            display: none; /* Hidden until connected */
        }
        
        #client-overlay {
            position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none;
            color: white; font-weight: bold; text-shadow: 1px 1px 2px black; font-size: 20px; z-index: 60;
        }
        
        .debug-btn { margin-top: 10px; padding: 5px 10px; background: #ffaaaa; border: 1px solid red; cursor: pointer; font-size: 12px;}
    </style>
</head>
<body>

    <div id="host-ui">
        <div id="game-ui">
            <div class="hud-top">
                <div class="score-box score-p1">P1<br><span id="score-p1-val">0%</span></div>
                <div id="timer-box">60</div>
                <div class="score-box score-p2">P2<br><span id="score-p2-val">0%</span></div>
            </div>
        </div>
        
        <div id="qr-panel">
            <h2 style="margin:0;">COLOUR SPLASH</h2>
            <div id="qrcode"></div>
            <div>
                <p style="margin:5px;">ID:</p>
                <div id="host-id-display">Generating...</div>
            </div>
            <p id="waiting-text" style="color: #666; margin-top: 10px;">Waiting for players...</p>
            
            <button class="debug-btn" onclick="startGame()">‚ö†Ô∏è FORCE START (DEBUG)</button>
        </div>

        <div id="game-over">
            <h1 style="margin:0;">GAME OVER</h1>
            <div id="winner-text" style="font-size: 40px; font-weight: bold; margin: 20px 0;">-</div>
            <button onclick="location.reload()" style="padding: 10px 30px; font-size: 18px; background: #333; color: white; cursor: pointer;">RESTART</button>
        </div>
    </div>

    <div id="client-ui">
        <div id="manual-login">
            <h2>JOIN GAME</h2>
            <input type="text" id="host-id-input" placeholder="Enter Host ID">
            <button class="join-btn" onclick="manualJoin()">CONNECT</button>
            <div id="client-status" style="margin-top: 15px; color: #666;"></div>
        </div>

        <div id="zone_joystick"></div>
        <div id="client-overlay">CONNECTING...</div>
    </div>

<script>
    // --- CONFIG ---
    const CONFIG = {
        arenaSize: 70,
        textureSize: 512,
        duration: 60,
        speed: 0.6,
        colors: { p1: '#ff4444', p2: '#4488ff', floor: '#ffffff' }
    };

    // --- ROUTER ---
    const urlParams = new URLSearchParams(window.location.search);
    const urlHostID = urlParams.get('host');

    window.addEventListener('load', () => {
        if (urlHostID) initClient(urlHostID);
        else initHost();
    });

    // ==========================================
    // HOST SYSTEM
    // ==========================================
    // Membuat variabel global untuk StartGame agar bisa diakses tombol Force Start
    window.startGame = null; 

    function initHost() {
        if(window.innerWidth < 600 && !confirm("Layar kecil? Klik Cancel untuk mode Controller.")) {
             document.getElementById('host-ui').style.display = 'none';
             initClient(null); return;
        }

        document.getElementById('host-ui').style.display = 'block';

        const peer = new Peer(); 
        
        // Player States
        const players = {
            p1: { active: false, x: -15, z: 0, vx: 0, vz: 0, mesh: null, color: CONFIG.colors.p1, size: 1, speedBuff: 1 },
            p2: { active: false, x: 15, z: 0, vx: 0, vz: 0, mesh: null, color: CONFIG.colors.p2, size: 1, speedBuff: 1 }
        };

        // Network
        peer.on('open', (id) => {
            document.getElementById('host-id-display').innerText = id;
            const link = window.location.href.split('?')[0] + '?host=' + id;
            new QRCode(document.getElementById("qrcode"), { text: link, width: 150, height: 150 });
        });

        peer.on('connection', (conn) => {
            conn.on('open', () => {
                let pid = !players.p1.active ? 'p1' : (!players.p2.active ? 'p2' : null);
                
                if(pid) {
                    players[pid].active = true;
                    conn.send({ type: 'init', color: pid === 'p1' ? 'RED' : 'BLUE' });
                    document.getElementById('waiting-text').innerText = `${pid.toUpperCase()} JOINED!`;
                    
                    // Terima Data Analog: { x, y } (Vector normalized)
                    conn.on('data', (data) => {
                        if(data.x !== undefined && data.y !== undefined) {
                            // Map joystick vector to velocity
                            // Joystick Y is Up(-)/Down(+), 3D Z is Back(-)/Forward(+)
                            players[pid].vx = data.x;
                            players[pid].vz = data.y; 
                        }
                    });

                    conn.on('close', () => players[pid].active = false);

                    // Auto start jika 2 player
                    if(players.p1.active && players.p2.active) window.startGame();
                } else {
                    conn.send({ type: 'full' });
                }
            });
        });

        // --- 3D SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 80, 60); // Kamera lebih tinggi untuk view luas
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('host-ui').prepend(renderer.domElement);

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.left = -50; dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50; dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // --- PAINT SYSTEM ---
        const canvas = document.createElement('canvas');
        canvas.width = CONFIG.textureSize; canvas.height = CONFIG.textureSize;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,CONFIG.textureSize,CONFIG.textureSize);
        
        const floorTex = new THREE.CanvasTexture(canvas);
        const floorGeo = new THREE.PlaneGeometry(CONFIG.arenaSize, CONFIG.arenaSize);
        const floorMat = new THREE.MeshStandardMaterial({ map: floorTex });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI/2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Grid
        const grid = new THREE.GridHelper(CONFIG.arenaSize, 14, 0x888888, 0xcccccc);
        grid.position.y = 0.1;
        scene.add(grid);

        // Walls
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const createWall = (w,d,x,z) => {
            const m = new THREE.Mesh(new THREE.BoxGeometry(w, 4, d), wallMat);
            m.position.set(x, 2, z); m.castShadow = true; scene.add(m);
        };
        const offset = CONFIG.arenaSize/2 + 1;
        createWall(CONFIG.arenaSize+2, 2, 0, -offset); // Top
        createWall(CONFIG.arenaSize+2, 2, 0, offset);  // Bottom
        createWall(2, CONFIG.arenaSize+2, -offset, 0); // Left
        createWall(2, CONFIG.arenaSize+2, offset, 0);  // Right

        // Players Mesh
        function createPlayer(color, x) {
            const g = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(2, 16, 16),
                new THREE.MeshStandardMaterial({ color: color })
            );
            body.position.y = 2; body.castShadow = true;
            g.add(body);
            
            // Pointer ring
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(2.5, 3, 32),
                new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI/2; ring.position.y = 0.2;
            g.add(ring);
            
            g.position.set(x, 0, 0);
            scene.add(g);
            return g;
        }

        players.p1.mesh = createPlayer(CONFIG.colors.p1, players.p1.x);
        players.p2.mesh = createPlayer(CONFIG.colors.p2, players.p2.x);

        // --- SKILL SYSTEM ---
        let skills = [];
        const SKILL_DEF = [
            { type: 'BOMB', color: 'black', label: 'üí£' },
            { type: 'SPEED', color: 'yellow', label: '‚ö°' },
            { type: 'BIG', color: '#00ff00', label: 'üçÑ' }
        ];

        function spawnSkill() {
            const def = SKILL_DEF[Math.floor(Math.random() * SKILL_DEF.length)];
            const x = (Math.random() - 0.5) * (CONFIG.arenaSize - 10);
            const z = (Math.random() - 0.5) * (CONFIG.arenaSize - 10);
            
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(1.5),
                new THREE.MeshPhongMaterial({ color: def.color, transparent: true, opacity: 0.7 })
            );
            mesh.position.set(x, 2, z);
            
            // Simple text label using DOM
            const el = document.createElement('div');
            el.innerText = def.label;
            el.style.cssText = "position:absolute; font-size:20px; color:white; font-weight:bold; text-shadow:0 0 5px black; display:none;";
            document.body.appendChild(el);

            scene.add(mesh);
            skills.push({ mesh, el, def, x, z, active: true });
        }

        // --- GAME LOOP ---
        let isRunning = false;
        let timeLeft = CONFIG.duration;
        let frame = 0;

        // Painting Logic
        function paint(x, z, color, size) {
            const cx = ((x + CONFIG.arenaSize/2) / CONFIG.arenaSize) * CONFIG.textureSize;
            const cz = ((z + CONFIG.arenaSize/2) / CONFIG.arenaSize) * CONFIG.textureSize;
            
            ctx.beginPath();
            ctx.arc(cx, cz, (size * 5), 0, Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();
            floorTex.needsUpdate = true;
        }

        // Score Calc
        function updateScore() {
            // Sample pixel (low res check for performance)
            const data = ctx.getImageData(0,0, CONFIG.textureSize, CONFIG.textureSize).data;
            let p1 = 0, p2 = 0, total = 0;
            for(let i=0; i<data.length; i+=16) { // Check every 4th pixel
                if(data[i] > 150 && data[i+2] < 100) p1++;
                if(data[i+2] > 150 && data[i] < 100) p2++;
                total++;
            }
            document.getElementById('score-p1-val').innerText = Math.floor((p1/total)*100) + '%';
            document.getElementById('score-p2-val').innerText = Math.floor((p2/total)*100) + '%';
            return { p1, p2 };
        }

        window.startGame = function() {
            if(isRunning) return;
            isRunning = true;
            document.getElementById('qr-panel').style.display = 'none';
            
            // Timer
            const tInt = setInterval(() => {
                timeLeft--;
                document.getElementById('timer-box').innerText = timeLeft;
                if(timeLeft % 2 === 0) updateScore();
                if(timeLeft <= 0) {
                    clearInterval(tInt);
                    isRunning = false;
                    const final = updateScore();
                    let winner = "DRAW";
                    if(final.p1 > final.p2) winner = "RED WINS!";
                    if(final.p2 > final.p1) winner = "BLUE WINS!";
                    
                    document.getElementById('winner-text').innerText = winner;
                    document.getElementById('winner-text').style.color = final.p1 > final.p2 ? CONFIG.colors.p1 : CONFIG.colors.p2;
                    document.getElementById('game-over').style.display = 'block';
                }
            }, 1000);

            animate();
        };

        function animate() {
            if(!isRunning) return;
            requestAnimationFrame(animate);
            frame++;

            if(frame % 200 === 0) spawnSkill();

            // Loop Players
            ['p1', 'p2'].forEach(id => {
                const p = players[id];
                // Support Force Start logic (player active OR host testing P1)
                const isForceActive = (id === 'p1' && !p.active); 
                if (!p.active && !isForceActive) return;

                // Move Physics (Direct Control)
                const speed = CONFIG.speed * p.speedBuff;
                let nx = p.x + (p.vx * speed);
                let nz = p.z + (p.vz * speed);

                // Collision Wall
                const limit = CONFIG.arenaSize/2 - 2;
                if(nx > limit || nx < -limit) nx = p.x;
                if(nz > limit || nz < -limit) nz = p.z;
                
                p.x = nx; p.z = nz;
                p.mesh.position.set(p.x, 0, p.z);
                
                // Visual Scale
                const targetScale = p.size;
                p.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);

                // Paint
                paint(p.x, p.z, p.color, p.size);

                // Skill Collision
                skills.forEach(s => {
                    if(!s.active) return;
                    const d = Math.hypot(p.x - s.x, p.z - s.z);
                    if(d < 3 * p.size) {
                        s.active = false;
                        scene.remove(s.mesh);
                        s.el.remove();
                        
                        if(s.def.type === 'BOMB') {
                            paint(p.x, p.z, p.color, 15);
                        } else if(s.def.type === 'SPEED') {
                            p.speedBuff = 2;
                            setTimeout(()=> p.speedBuff = 1, 5000);
                        } else if(s.def.type === 'BIG') {
                            p.size = 2.5;
                            setTimeout(()=> p.size = 1, 8000);
                        }
                    }
                });
            });

            // Update Labels
            skills.forEach(s => {
                if(s.active) {
                    const vec = new THREE.Vector3(s.x, 3, s.z).project(camera);
                    const x = (vec.x * .5 + .5) * window.innerWidth;
                    const y = (-(vec.y * .5) + .5) * window.innerHeight;
                    s.el.style.display = 'block';
                    s.el.style.left = x + 'px';
                    s.el.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // ==========================================
    // CLIENT SYSTEM (ANALOG)
    // ==========================================
    window.manualJoin = function() {
        const id = document.getElementById('host-id-input').value.trim();
        if(id) initClient(id);
    }

    function initClient(hostId) {
        document.getElementById('host-ui').style.display = 'none';
        document.getElementById('client-ui').style.display = 'block';
        
        const overlay = document.getElementById('client-overlay');
        overlay.innerText = "CONNECTING TO " + hostId + "...";

        const peer = new Peer();
        let conn = null;

        peer.on('open', () => {
            conn = peer.connect(hostId);
            
            conn.on('open', () => {
                document.getElementById('manual-login').style.display = 'none';
                document.getElementById('zone_joystick').style.display = 'block';
                overlay.innerText = "WAITING FOR START...";
                
                // --- NIPPLE.JS SETUP ---
                const manager = nipplejs.create({
                    zone: document.getElementById('zone_joystick'),
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'white',
                    size: 150
                });

                // Send Data Loop
                let moveData = { x: 0, y: 0 };
                
                manager.on('move', (evt, data) => {
                    // Convert angle/force to Vector XY
                    // Nipple output: vector {x, y} normalized
                    if(data.vector) {
                        // Invert Y because screen Y is down, but 3D Z forward is usually negative/positive logic depending on camera
                        // Here: Up on screen (Y neg) -> Move Forward (Z neg)
                        moveData.x = data.vector.x; 
                        moveData.y = -data.vector.y; 
                    }
                });

                manager.on('end', () => {
                    moveData = { x: 0, y: 0 };
                });

                // Throttle sending to 30ms to save bandwidth
                setInterval(() => {
                    if(conn.open) conn.send(moveData);
                }, 30);
            });

            conn.on('data', (data) => {
                if(data.type === 'init') {
                    overlay.innerText = `YOU ARE ${data.color}`;
                    document.getElementById('zone_joystick').style.background = 
                        data.color === 'RED' 
                        ? 'radial-gradient(circle, #800 1%, #200 100%)' 
                        : 'radial-gradient(circle, #008 1%, #002 100%)';
                }
                else if(data.type === 'full') {
                    alert("Room Full"); location.reload();
                }
            });
            
            conn.on('close', () => { alert("Host Closed"); location.reload(); });
            
            // Timeout check
            setTimeout(() => {
                if(!conn.open) overlay.innerText = "CONNECTION FAILED. TRY RELOAD.";
            }, 8000);
        });
    }
</script>
</body>
</html>
