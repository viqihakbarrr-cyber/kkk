<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Dodge: Dual Player</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background: #000; color: white; touch-action: none; }
        
        /* HOST UI */
        #host-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; }
        
        #qr-container { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #00ffcc;
            pointer-events: auto; z-index: 10;
        }
        
        #game-info { position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; text-shadow: 0 0 5px #000; z-index: 5; }
        .p1-score { color: #ff3333; }
        .p2-score { color: #3388ff; }
        
        #game-over { 
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 50px; color: red; text-align: center; background: rgba(0,0,0,0.9); padding: 40px; z-index: 20;
        }

        /* CLIENT UI */
        #client-ui { display: none; width: 100%; height: 100vh; flex-direction: column; align-items: center; justify-content: center; background: #222; }
        .control-area { display: flex; width: 100%; height: 100%; }
        .btn { flex: 1; border: none; font-size: 40px; font-weight: bold; color: white; cursor: pointer; }
        .btn-left { background: linear-gradient(to right, #444, #666); border-right: 1px solid #222; }
        .btn-right { background: linear-gradient(to right, #666, #444); }
        .btn:active { background: #888; }
        #status-text { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; font-size: 18px; z-index: 5; }
    </style>
</head>
<body>

    <div id="host-ui">
        <div id="game-info">
            WAVE: <span id="wave-disp">1</span> | 
            P1: <span id="p1-lives" class="p1-score">ALIVE</span> | 
            P2: <span id="p2-lives" class="p2-score">WAITING...</span>
        </div>
        
        <div id="qr-container">
            <h2 style="margin-top:0;">Scan to Join</h2>
            <div id="qrcode" style="display: flex; justify-content: center;"></div>
            <p style="font-size: 14px; color: #ccc; margin-top: 10px;">
                Player 1 & Player 2 scan same code<br>
                <small id="loading-msg">Generating ID...</small>
            </p>
        </div>

        <div id="game-over">
            GAME OVER<br>
            <span id="final-score" style="font-size: 20px; color: white;"></span><br>
            <button onclick="location.reload()" style="font-size: 20px; padding: 10px; margin-top: 20px; cursor: pointer;">RESTART</button>
        </div>
    </div>

    <div id="client-ui">
        <div id="status-text">Connecting...</div>
        <div class="control-area">
            <button class="btn btn-left" id="btn-left"><</button>
            <button class="btn btn-right" id="btn-right">></button>
        </div>
    </div>

<script>
    // --- UTILS ---
    const getParams = () => new URLSearchParams(window.location.search);
    
    // --- CONFIGURATION ---
    const CONFIG = {
        arenaWidth: 30,
        playerSpeed: 0.3,
        baseSpawnRate: 60,
        colors: { p1: 0xff3333, p2: 0x3388ff, ground: 0x222222, meteor: 0xffaa00 }
    };

    // ==========================================
    // LOGIC ROUTER
    // ==========================================
    const hostID = getParams().get('host');

    // Pastikan DOM sudah load sebelum menjalankan logic
    window.addEventListener('load', () => {
        if (hostID) {
            initClient(hostID);
        } else {
            initHost();
        }
    });

    // ==========================================
    // HOST LOGIC
    // ==========================================
    function initHost() {
        // Tampilkan UI Host
        const hostDiv = document.getElementById('host-ui');
        if(hostDiv) hostDiv.style.display = 'block';

        // 1. Networking (Host)
        const peer = new Peer(null, { debug: 1 });
        
        const players = {
            p1: { conn: null, x: -5, active: false, alive: true, obj: null },
            p2: { conn: null, x: 5, active: false, alive: true, obj: null }
        };

        peer.on('open', (id) => {
            console.log('Host ID:', id);
            document.getElementById('loading-msg').style.display = 'none'; // Sembunyikan loading
            
            const joinUrl = `${window.location.href.split('?')[0]}?host=${id}`;
            
            // Clear QR lama jika ada
            document.getElementById("qrcode").innerHTML = "";
            
            new QRCode(document.getElementById("qrcode"), {
                text: joinUrl,
                width: 200,
                height: 200,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.H
            });
        });

        peer.on('error', (err) => {
            console.error(err);
            alert("Error PeerJS: " + err.type);
        });

        peer.on('connection', (conn) => {
            conn.on('open', () => {
                let assigned = false;
                if (!players.p1.active) {
                    players.p1.conn = conn;
                    players.p1.active = true;
                    document.getElementById('p1-lives').innerText = "READY";
                    assigned = 'p1';
                } else if (!players.p2.active) {
                    players.p2.conn = conn;
                    players.p2.active = true;
                    document.getElementById('p2-lives').innerText = "READY";
                    assigned = 'p2';
                    
                    // Mulai game saat P2 masuk
                    document.getElementById('qr-container').style.display = 'none';
                    startGameLoop();
                }

                if(assigned) {
                    conn.send({ type: 'init', player: assigned, color: assigned === 'p1' ? 'RED' : 'BLUE' });
                    
                    conn.on('data', (data) => {
                        if (data.move !== undefined && players[assigned].alive) {
                            players[assigned].moveDir = data.move;
                        }
                    });
                    
                    conn.on('close', () => {
                        players[assigned].active = false;
                        players[assigned].alive = false;
                    });
                } else {
                    conn.send({ type: 'full' });
                    setTimeout(() => conn.close(), 500);
                }
            });
        });

        // 2. Three.js Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 15, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Masukkan canvas ke dalam host-ui agar tidak menimpa elemen lain
        hostDiv.insertBefore(renderer.domElement, hostDiv.firstChild);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // Grid & Plane
        const gridHelper = new THREE.GridHelper(CONFIG.arenaWidth, 20, 0x00ffcc, 0x444444);
        scene.add(gridHelper);
        
        const planeGeo = new THREE.PlaneGeometry(CONFIG.arenaWidth, 100);
        const planeMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -0.1;
        scene.add(plane);

        // Player Meshes
        function createPlayerMesh(color, x) {
            const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0.75, 5);
            scene.add(mesh);
            return mesh;
        }

        players.p1.obj = createPlayerMesh(CONFIG.colors.p1, -5);
        players.p2.obj = createPlayerMesh(CONFIG.colors.p2, 5);

        // Game Loop Variables
        let obstacles = [];
        let frame = 0;
        let wave = 1;
        let isGameOver = false;
        let gameRunning = false;

        function spawnObstacle() {
            const size = Math.random() * 1.5 + 0.5;
            const geo = new THREE.DodecahedronGeometry(size);
            const mat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.meteor, flatShading: true });
            const mesh = new THREE.Mesh(geo, mat);
            
            const xPos = (Math.random() * CONFIG.arenaWidth) - (CONFIG.arenaWidth / 2);
            mesh.position.set(xPos, 15 + Math.random() * 5, -40);
            
            scene.add(mesh);
            obstacles.push({ mesh: mesh, speed: 0.2 + (wave * 0.05), vy: -0.15 });
        }

        function updatePhysics() {
            if (!gameRunning || isGameOver) return;

            frame++;
            if (frame % 600 === 0) {
                wave++;
                document.getElementById('wave-disp').innerText = wave;
            }

            const spawnRate = Math.max(15, CONFIG.baseSpawnRate - (wave * 5));
            if (frame % spawnRate === 0) spawnObstacle();

            // Player Movement
            ['p1', 'p2'].forEach(key => {
                const p = players[key];
                if (p.alive && p.active && p.moveDir !== undefined) {
                    p.x += p.moveDir * CONFIG.playerSpeed;
                    
                    const limit = CONFIG.arenaWidth / 2 - 1;
                    if (p.x < -limit) p.x = -limit;
                    if (p.x > limit) p.x = limit;
                    
                    p.obj.position.x += (p.x - p.obj.position.x) * 0.2;
                    p.obj.rotation.z = -p.moveDir * 0.2;
                } else if (!p.alive) {
                    p.obj.visible = false;
                } else {
                    p.obj.rotation.z = 0;
                }
            });

            // Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.mesh.position.z += obs.speed;
                if (obs.mesh.position.y > 0.75) obs.mesh.position.y += obs.vy;

                // Collision
                ['p1', 'p2'].forEach(key => {
                    const p = players[key];
                    if (p.alive && p.active) {
                        const dist = p.obj.position.distanceTo(obs.mesh.position);
                        if (dist < 2.0) {
                            p.alive = false;
                            document.getElementById(`${key}-lives`).innerText = "DEAD";
                            p.obj.scale.set(0.1,0.1,0.1);
                        }
                    }
                });

                if (obs.mesh.position.z > 10) {
                    scene.remove(obs.mesh);
                    obstacles.splice(i, 1);
                }
            }

            // Check Game Over
            if (players.p1.active && players.p2.active) {
                if (!players.p1.alive && !players.p2.alive) endGame();
            }
        }

        function endGame() {
            isGameOver = true;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = `WAVES SURVIVED: ${wave}`;
        }

        function startGameLoop() {
            if (gameRunning) return;
            gameRunning = true;
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // ==========================================
    // CLIENT LOGIC
    // ==========================================
    function initClient(targetId) {
        document.getElementById('host-ui').style.display = 'none';
        document.getElementById('client-ui').style.display = 'flex';
        
        const peer = new Peer();
        let conn = null;
        const statusText = document.getElementById('status-text');

        peer.on('open', (id) => {
            statusText.innerText = "Finding Host...";
            conn = peer.connect(targetId);

            conn.on('open', () => {
                statusText.innerText = "Connected! Waiting...";
            });

            conn.on('data', (data) => {
                if (data.type === 'init') {
                    document.body.style.background = data.color === 'RED' ? '#500' : '#005';
                    statusText.innerText = `YOU ARE ${data.color}`;
                } else if (data.type === 'full') {
                    statusText.innerText = "Game Full!";
                }
            });
            
            conn.on('close', () => statusText.innerText = "Disconnected.");
            conn.on('error', () => statusText.innerText = "Connection Error");
        });

        const sendMove = (dir) => {
            if (conn && conn.open) conn.send({ move: dir });
        };

        const setupBtn = (id, dir) => {
            const btn = document.getElementById(id);
            const start = (e) => { e.preventDefault(); sendMove(dir); btn.style.background='#999'; };
            const end = (e) => { e.preventDefault(); sendMove(0); btn.style.background=''; };
            
            btn.addEventListener('touchstart', start);
            btn.addEventListener('touchend', end);
            btn.addEventListener('mousedown', start);
            btn.addEventListener('mouseup', end);
        };

        setupBtn('btn-left', -1);
        setupBtn('btn-right', 1);
    }
</script>
</body>
</html>
