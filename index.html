<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Dodge: Dual Player</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background: #000; color: white; touch-action: none; }
        
        /* HOST UI */
        #host-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        #qr-container { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid #00ffcc;
            pointer-events: auto;
        }
        #game-info { position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; text-shadow: 0 0 5px #000; }
        .p1-score { color: #ff3333; }
        .p2-score { color: #3388ff; }
        #game-over { 
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 50px; color: red; text-align: center; background: rgba(0,0,0,0.9); padding: 40px; z-index: 10;
        }

        /* CLIENT UI */
        #client-ui { display: none; width: 100%; height: 100vh; flex-direction: column; align-items: center; justify-content: center; background: #222; }
        .control-area { display: flex; width: 100%; height: 100%; }
        .btn { flex: 1; border: none; font-size: 40px; font-weight: bold; color: white; active: opacity: 0.7; }
        .btn-left { background: linear-gradient(to right, #444, #666); border-right: 1px solid #222; }
        .btn-right { background: linear-gradient(to right, #666, #444); }
        .btn:active { background: #888; }
        #status-text { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; font-size: 18px;}
    </style>
</head>
<body>

    <div id="host-view">
        <div id="game-info">
            WAVE: <span id="wave-disp">1</span> | 
            P1 (RED): <span id="p1-lives" class="p1-score">ALIVE</span> | 
            P2 (BLUE): <span id="p2-lives" class="p2-score">WAITING...</span>
        </div>
        <div id="qr-container">
            <h2 style="margin-top:0;">Scan to Join</h2>
            <div id="qrcode"></div>
            <p style="font-size: 14px; color: #ccc;">Player 1 & Player 2 scan same code</p>
        </div>
        <div id="game-over">
            GAME OVER<br>
            <span id="final-score" style="font-size: 20px; color: white;"></span><br>
            <button onclick="location.reload()" style="font-size: 20px; padding: 10px; margin-top: 20px; cursor: pointer;">RESTART</button>
        </div>
    </div>

    <div id="client-ui">
        <div id="status-text">Connecting...</div>
        <div class="control-area">
            <button class="btn btn-left" id="btn-left"><</button>
            <button class="btn btn-right" id="btn-right">></button>
        </div>
    </div>

<script>
    // --- UTILS ---
    const getParams = () => new URLSearchParams(window.location.search);
    const isMobile = /Android|iPhone/i.test(navigator.userAgent);

    // --- CONFIGURATION ---
    const CONFIG = {
        arenaWidth: 30,
        playerSpeed: 0.3,
        baseSpawnRate: 60, // Frames
        colors: { p1: 0xff3333, p2: 0x3388ff, ground: 0x222222, meteor: 0xffaa00 }
    };

    // ==========================================
    // LOGIC ROUTER
    // ==========================================
    const hostID = getParams().get('host');

    if (hostID) {
        initClient(hostID);
    } else {
        initHost();
    }

    // ==========================================
    // HOST LOGIC (Game Engine & Rendering)
    // ==========================================
    function initHost() {
        document.getElementById('host-ui').style.display = 'block'; // Logic handled by visibility of divs
        
        // 1. Networking (Host)
        const peer = new Peer(null, { debug: 1 }); // Let PeerJS server assign ID
        const players = {
            p1: { conn: null, x: -5, active: false, alive: true, obj: null },
            p2: { conn: null, x: 5, active: false, alive: true, obj: null }
        };

        peer.on('open', (id) => {
            console.log('Host ID:', id);
            const joinUrl = `${window.location.href.split('?')[0]}?host=${id}`;
            new QRCode(document.getElementById("qrcode"), {
                text: joinUrl,
                width: 200,
                height: 200
            });
        });

        peer.on('connection', (conn) => {
            conn.on('open', () => {
                let assigned = false;
                if (!players.p1.active) {
                    players.p1.conn = conn;
                    players.p1.active = true;
                    document.getElementById('p1-lives').innerText = "READY";
                    assigned = 'p1';
                } else if (!players.p2.active) {
                    players.p2.conn = conn;
                    players.p2.active = true;
                    document.getElementById('p2-lives').innerText = "READY";
                    assigned = 'p2';
                    // Hide QR when P2 joins
                    document.getElementById('qr-container').style.display = 'none';
                    startGameLoop();
                }

                if(assigned) {
                    conn.send({ type: 'init', player: assigned, color: assigned === 'p1' ? 'RED' : 'BLUE' });
                    conn.on('data', (data) => {
                        if (data.move && players[assigned].alive) {
                            // Update intended position or velocity
                            players[assigned].moveDir = data.move; // -1, 0, 1
                        }
                    });
                    conn.on('close', () => {
                        players[assigned].active = false;
                        players[assigned].alive = false;
                        // Handle disconnect logic if needed
                    });
                } else {
                    conn.send({ type: 'full' });
                    conn.close();
                }
            });
        });

        // 2. Three.js Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 15, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // Arena (Grid)
        const gridHelper = new THREE.GridHelper(CONFIG.arenaWidth, 20, 0x00ffcc, 0x444444);
        scene.add(gridHelper);
        
        // Ground Plane (Invisible mostly, for contrast)
        const planeGeo = new THREE.PlaneGeometry(CONFIG.arenaWidth, 100);
        const planeMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -0.1;
        scene.add(plane);

        // Players
        function createPlayerMesh(color, x) {
            const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0.75, 5);
            scene.add(mesh);
            return mesh;
        }

        players.p1.obj = createPlayerMesh(CONFIG.colors.p1, -5);
        players.p2.obj = createPlayerMesh(CONFIG.colors.p2, 5);

        // Game State
        let obstacles = [];
        let frame = 0;
        let wave = 1;
        let isGameOver = false;
        let gameRunning = false;

        function spawnObstacle() {
            const size = Math.random() * 1.5 + 0.5;
            const geo = new THREE.DodecahedronGeometry(size);
            const mat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.meteor, flatShading: true });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Random start X within arena
            const xPos = (Math.random() * CONFIG.arenaWidth) - (CONFIG.arenaWidth / 2);
            mesh.position.set(xPos, 1, -40); // Spawn far back
            
            // Give it some "falling from sky" effect trajectory
            mesh.position.y = 10 + Math.random() * 5;
            
            scene.add(mesh);
            obstacles.push({ mesh: mesh, speed: 0.2 + (wave * 0.05), vy: -0.1 });
        }

        function updatePhysics() {
            if (!gameRunning || isGameOver) return;

            // Update Wave
            frame++;
            if (frame % 600 === 0) {
                wave++;
                document.getElementById('wave-disp').innerText = wave;
            }

            // Spawn Logic
            const spawnRate = Math.max(10, CONFIG.baseSpawnRate - (wave * 5));
            if (frame % spawnRate === 0) {
                spawnObstacle();
            }

            // Move Players
            ['p1', 'p2'].forEach(key => {
                const p = players[key];
                if (p.alive && p.active && p.moveDir) {
                    p.x += p.moveDir * CONFIG.playerSpeed;
                    // Clamp
                    const limit = CONFIG.arenaWidth / 2 - 1;
                    if (p.x < -limit) p.x = -limit;
                    if (p.x > limit) p.x = limit;
                    
                    p.obj.position.x += (p.x - p.obj.position.x) * 0.2; // Smooth lerp
                    p.obj.rotation.z = -p.moveDir * 0.2; // Tilt effect
                } else if (!p.alive) {
                    p.obj.visible = false;
                } else {
                    p.obj.rotation.z = 0;
                }
            });

            // Move Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.mesh.position.z += obs.speed;
                
                // Falling effect
                if (obs.mesh.position.y > 0.75) {
                    obs.mesh.position.y += obs.vy;
                }

                // Collision Check
                ['p1', 'p2'].forEach(key => {
                    const p = players[key];
                    if (p.alive && p.active) {
                        const dist = p.obj.position.distanceTo(obs.mesh.position);
                        if (dist < 2.0) {
                            // Hit!
                            p.alive = false;
                            document.getElementById(`${key}-lives`).innerText = "DEAD";
                            
                            // Visual explosion placeholder (scale down)
                            p.obj.scale.set(0.1,0.1,0.1);
                        }
                    }
                });

                // Cleanup
                if (obs.mesh.position.z > 10) {
                    scene.remove(obs.mesh);
                    obstacles.splice(i, 1);
                }
            }

            // Game Over Check
            if (players.p1.active && players.p2.active) {
                if (!players.p1.alive && !players.p2.alive) {
                    endGame();
                }
            }
        }

        function endGame() {
            isGameOver = true;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = `WAVES SURVIVED: ${wave}`;
        }

        function startGameLoop() {
            if (gameRunning) return;
            gameRunning = true;
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // ==========================================
    // CLIENT LOGIC (Controller)
    // ==========================================
    function initClient(targetId) {
        document.getElementById('host-view').style.display = 'none'; // Hide host
        document.getElementById('client-ui').style.display = 'flex'; // Show controls
        
        const peer = new Peer();
        let conn = null;
        let moveState = 0; // -1 left, 0 stop, 1 right

        const statusText = document.getElementById('status-text');

        peer.on('open', (id) => {
            statusText.innerText = "Finding Host...";
            conn = peer.connect(targetId);

            conn.on('open', () => {
                statusText.innerText = "Connected! Waiting for Game Start...";
            });

            conn.on('data', (data) => {
                if (data.type === 'init') {
                    document.body.style.background = data.color === 'RED' ? '#500' : '#005';
                    statusText.innerText = `YOU ARE ${data.color}`;
                } else if (data.type === 'full') {
                    statusText.innerText = "Game Full!";
                }
            });

            conn.on('close', () => {
                statusText.innerText = "Disconnected.";
                document.body.style.background = "#333";
            });
        });

        // Input Handling
        const sendMove = (dir) => {
            if (conn && conn.open) {
                conn.send({ move: dir });
            }
        };

        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');

        const startLeft = (e) => { e.preventDefault(); sendMove(-1); btnLeft.style.background='#999'; };
        const endLeft = (e) => { e.preventDefault(); sendMove(0); btnLeft.style.background=''; };
        
        const startRight = (e) => { e.preventDefault(); sendMove(1); btnRight.style.background='#999'; };
        const endRight = (e) => { e.preventDefault(); sendMove(0); btnRight.style.background=''; };

        // Touch events
        btnLeft.addEventListener('touchstart', startLeft);
        btnLeft.addEventListener('touchend', endLeft);
        btnRight.addEventListener('touchstart', startRight);
        btnRight.addEventListener('touchend', endRight);

        // Mouse events (for testing on desktop)
        btnLeft.addEventListener('mousedown', startLeft);
        btnLeft.addEventListener('mouseup', endLeft);
        btnRight.addEventListener('mousedown', startRight);
        btnRight.addEventListener('mouseup', endRight);
    }

</script>
</body>
</html>
